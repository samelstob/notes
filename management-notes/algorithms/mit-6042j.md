# 6.042J Mathematics for Computer Science

# Proofs

* "Distinguish a very plausible argument which might not be totally right from
  a proof which is totally right"

* a^2 + b^2 = c^2
  - Is it familiar - yes, is it obvious no
* Over 100 proofs
* Proof by picture
  - worrisome in general
  - hidden assumptions
  - *Proofs by picture are often very convincing and very wrong*

## Proofs exist beyond mathematics

* A proof is a method for ascertaining (establishing, verifying) the truth 
* Experiment and observation
* Sampling and counterexamples: Truth is the opposite of falsehood - find counterexamples
* Jury and judges
* Word of authority, word of god 
* Inner conviction - very popular in computer science!
  - "There are no bugs in my code"
  - "I don't see why not"
* A mathematical proof is a verification of a proposition by a chain of logical
  deductions from a set of of axioms 
  - Proposition
  - Logical deductions
  - Axioms

## Propositions

* A proposition is a statement that is either true or false
   ε

  For all n in the natural numbers {0,1,2,3,...} n^2+n+41 is prime

  ^ quantifier     ^ universe of discourse        ^ predicate

  A predicate is a proposition whose truth depends on the value of a variable

  To see if this proposition is true we need to see if this predicate is true
for all natural numbers

  n     n^2+n+41    prime 
  0     41          y
  1     43          y
  2     47          Y
  3     53          Y
  20    461         y
  39    1601        y

The first 40 values of n the proposition is true.  In a lot of fields e.g. physics,
statistics if you checked 40 examples "it must be true".

  40    1681        n

Example:

  a^4 + b^4 + c^4 = d^4   has no positive integer solutions

  This proposition was conjectured to be true by Euler in 1769.  It was
unsolved for 2 centuries.

  A counter example was found 2 centuries later.

  313(x^3 + y^3) = z^3 has no positive integer solutions

  false - but the shortest counter example has over a thousand digits - you
would never use a computer to exhaustively search

Why would you care?  This equation is an example of an elliptic curve.
Elliptic curve is used in cryptosystems.

Example: Map Colouring

  The regions of a map can be coloured in 4 colours so that adjacent regions
have different colours

Conjectured by Guthrie in 1853

There were many false proofs over the next century.  There was a convincing
proof for over a decade.  *Proofs by picture are often very convincing and very
wrong.*

The four colour theorem was finally proved in 1977 but they had to use a
computer to check thousands of cases.  This was disturbing to mathematicians -
how do you know the computer did the right thing.

A few years ago a 12 page human proof was discovered - but people are
suspicious.

Example: Goldbach's conjecture (1742) - Every positive even integer but 2 is the sum of 2 primes.  E.g. 24 is the sum of 11 and 13

    - No one knows - one of the great unsolved mysteries
  * Riemann hypothesis
  * Poincare conjecture - proved in 2003 - won the fields medal
    - All shapes in 3 dimensions are deformations of a sphere?

Example: For all n in the integers {0,1,-1,2,-2,...} n>2 implies n^2 > 4

## Definition: An implication p implies q is true if p is false or q is true

False implies anything is true i.e. "If pigs can fly, I am king" is *true* because
"p" is false

  p = false
  if p then q

Example: For all integers, n > 2 if and only if n^2 > 4
  - "if and only if" <==> has to applied both ways

  p     q     p => q    q => p      p <=> q
  T     T     T         T           T
  T     F     F         T           F 
  F     T     T         F           F
  F     F     T         T           T

## Axioms

* An axiom is a proposition that is assumed to be true

  - Axiom - from Greek "to think worthy"
  - Often we say don't make assumptions - you have to make assumptions
    otherwise you can't do anything!  They key is to identify your assumptions
so that people can see them.

* There are lots of axioms used in maths e.g. if a=b and b=c then a=c
* Euclidean geometry, spherical geometry, hyperbolic geometry seem to have
  conflicting axioms - this is fine as long as you declare you axioms
* Axioms *should* be consistent and complete (however...)

Definition:
  - Consistent: A set of axioms is consistent if no proposition to be both true and false
  - Complete: A set of axioms is complete if it can be used to prove every proposition
    is either true or false

Some mathematicians spent their entire careers trying to get to a set of
axioms that was consistent and complete. Kurt Godel in 1930s proved *it is not
possible there exists any set of axioms that is both consistent and complete.*

If a set of axioms is not complete you can state a problem that you can't
prove;  When you parents told you if you work hard enough you can do anything
- they were wrong.

SE I'm assuming you don't want your axioms to be inconsistent so you have to
settle for them being incomplete

# Lecture 2: Induction

## Proof by Contradiction - assume the opposite of what you are trying to prove

To prove a proposition P is true, we assume P is False then use that
hypothesis to derive a falsehood or contradiction

Example: Is cuberoot(1332) <= 11

Calculating the cuberoot of 1332 is hard.  Instead we can cube 11 and create a
contradiction to show that the proposition is false

    1332 <= 11³
    1332 <= 1331!

  Contradiction

Example: Theorem sqrt(2) is irrational

Pf (by Cont.)

Assume for purpose of contradiction that sqrt(2) is rational i.e. can be
defined as the ratio of two numbers

  sqrt(2) = a/b (fraction in lowest terms - i.e. a and b have no common
divisors)
  2 = a² / b²   # square both sides
  2b² = a²      # multiply by b²
  => a² is even (2 | a²)
  => a is even (2 | a)
    - XXXSE Because an odd number squared must be an odd number (r.h.s) and
      the l.h.s must be an even number
    - I think this is because the primes of a factor of a are primes of a (but
      I'm not 100% sure about that)
    - TODO Axiom: There is an axiom about factors here
  => 4 | a²
  => 4 | 2b²
  => 2 | b²  # divide each side by 2
  => b is even => a/b is not in lowest terms => contradiction
    - Because both a and b are even
  => sqrt(2) is irrational

In a 1x1 right-angled triangle the hypotenuse must be sqrt(2).  Pythagoras and
his followers didn't like that sqrt(2) was irrational.  This was inconsistent
with their axioms and irrational numbers were "the devil". They covered this
up from general society.

* Getting rich - proof by diagram - the error is in the first step - the
  diagram was incorrect

## 2015 1.2.3 Proof by Cases

Reasoning by cases breaks a complicated problem into easier sub-problems.

Some philosophers (intuitionists) think reasoning this way is worrisome

e.g. Is P = NP?

## 2015 1.3.1 Well Ordering Principal 1

One of those facts in mathematics that's so obvious that you hardly notice it.

Familiar? Yes, Obvious Yes, Trivial Yes, but watch out (e.g. rationals,
negative numbers)

* Every non-empty set of non-negative integers has a least element

* XXXSE What the fudge? Is this a principal?  Well it turns out that this is
  not true for rational numbers or for negative numbers

Find smallest number m such that

  sqrt(2) = m/n 

If m, n had a common factor, c>1, then

  sqrt(2) = (m/c)/(n/c)   and m/c < m

This contradiction implies m, n have no common factors

XXXSE But what about the fact that sqrt(2) is irrational?  I thought we were
going to prove that

## 1.3.3 Well Ordering Principal, II

Thm: Every integer > 1 is a product of primes

Proof: (by contradiction) Suppose {nonproducts} is non empty.  By the well
ordering principal there is a least m > 1 that is a nonproduct.

m is not a prime (else it would be a product of a prime with one - so not part
of the set of nonproducts) so it must be a product of two numbers:

  m = j.k

  1 < m < j, k

  By the WOP if m is the least element of {nonproducts} then j, k must be
product of primes.
  Contradiction: If j, k are the product of primes, then m must be.

### Well Ordered Postage

Thm: Every number >=8 can be made from 3c and 5c stamps

Lets define postal as 3a + 5b = n + 8

  3a + 5b - 8 = n

If the theorem is not true there must be a non-empty set of numbers which are
"non-postal" i.e. cannot be made from 3c and 5c stamps.  By the well ordering
principal this set must have a least element.

With WOP we begin by assuming there is a counter example.  If there is any
counter example there is a least one.

That is:

  m = least non-postal
  any number < m is postal

We can show by cases that every number up to n=3 is postal

n = 0   => a=1, b=1
n = 1   => a=3, b=0
n = 2   => a=0, b=2

By this point we know that m, the least non-postal number must be => 3

m-3 < m so must be postal.  However, we can just add 3, so m must also be
postal which is a contradiction.

XXXSE So picture the infinite set of positive integers

  1 2 3 4 5 6 7 8 9 10 11 12 ... 2455 2456 2457 2458 ... 9684844 9684845 9684846
                                                  ^
                                                  m

If we try picture the number "m" which is the least non-postal number.  We know
that by it's definition every number below "m" is postal.  If we subtract 3
from m we know it's a postal number, then we can simply add 3 to make it
postal.  But we just said "m" is non-postal.  This is a contradiction.  XXXSE What about if we subtract 2?  Well it doesn't matter because we
can subtract 3, or 5 for that matter - it's the same number.

XXXSE I think I prefer to think of it descending from a large number to a
smaller number.  Imagine a very large number "m" which purports to be the
least non-postal number.  We know that every number below this "m" is postal.
So even though "m" claims it is non-postal we can just say - "Hey, but if you
take the configuration of 3c and 5c stamps from your neighbour 3 positions
below you and then I give you another 3c stamp then that will make you
postal".  This means the real "m" must be lower than this.  We can continue
this until we reach a number less than 3.  We can then prove by cases that 0,
1, 2 are postal leaving no possible "m".

The key bit of new stuff here for *me* is the idea of using a principal and
logic to prove that every number >= 3 is postal.  I don't think we did this in
Maths class at school.  In the above we don't even have to know the
"configuration" of 3c and 5c stamps - we just know that it exists because we
have said it does for the purposes of the proof by WOP.  You can see how this
could be applied to a much more complex theorem.

XXXSE I don't feel it in my bones yet - I feel suspicious of it.  It feels
almost like sleight of hand or wordplay rather than a solid proof.  This is
actually quite mind bending if you really try to understand it.

If the WOP is not true then this proof falls apart.

# 2015 1.3.5 Well Ordering Principal, III

Geometric Sums

 1 + r + r^2 + r^3 + ... + r^n = r^(n+1)-1/r-1

Proof by WOP.  We assume that there is a number "m" which is the least element
that the above formula doesn't hold for.

XXXSE Imagine some number "m" in the infinite set of positive integers that this
doesn't hold for.  We know that it holds for every number less than "m".  So
it must hold for m-1.

The geometric sum of m must be the sum of geometric_sum(m-1) + r^m

    ((r^(m-1+1) - 1) / (r - 1)) + r^m

  = ((r^m - 1) / (r - 1)) + r^m

Simplify by putting r^m over the denominator r-1 by multiplying it by r-1

  r^m
  = r^m (r-1) / (r-1)
  = (r * r^m) - (1 * r^m) / (r-1)
  = r^(m+1) - r^m / (r-1)

  = ((r^m - 1) / (r - 1)) + (r^(m+1) - r^m / (r-1))
  = ((r^m - 1) + r^(m+1) - r^m) / (r-1)
  = (r^(m+1) - 1)/ (r-1)

Contradiction - we have shown that geometric sum of m *is* given by the
formula.

XXXSE So in a similar way to the postage we have shown that any candidate
least element "m" is contradicted by using a number less than "m" and showing
how to reach "m".

This feels a little like induction

## Well Ordering Principal Proofs

You have some property P(n) of non-negative integers and you would like to
prove that it holds for every non-negative integer.

  For all n in non-negative integers, P(n) holds

1. Define a set of counter examples

C is the set of non-negative integers for which not P(n) holds

  C ::= { n ε Ν | NOT P(n) }

2. Assume C is not empty.  By WOP there has got to be a minimum element m
   that's in C

3. Reach a contradiction somehow...

How you reach a contradiction is by reasoning properties of P(n) - there is no
simple recipe.  The usual organisation of the contradiction is one of two
kinds

i) Find a counterexample smaller than m
ii) Proove that P(m) is true

# 2015 1.4.1 Proposotions and Logical operations
# 2015 1.4.3 Digital Logical

Proposition Operators play a basic role in the design of digital circuitry.

"The way binary works is like decimal but instead of powers of 10 you are using
powers of 2"

## Adding in binary

  39 is 100111
  28 is 011100

Binary addition works just like decimal addition except that the only numbers
are 1's and 0's so when you get 1+1 you have to carry 1.

 carry  111000 
        100111
        011100
        ______
       1000011

## Binary addition circuit

      a5  a4  a3  a2  a1  a0
      b5  b4  b3  b2  b1  b0
  c5  c4  c3  c2  c1  c0
  c5  d5  d4  d3  d2  d1  d0

  "ripply carry"

  Half Adder - 2 inputs, 2 outputs

    d ::= a XOR b
    c ::= a AND b

  Full Adder - 3 inputs, 2 outputs

    in    | out
    a b c | d c
    0 0 0 | 0 0  
    0 0 1 | 1 0
    0 1 0 | 1 0
    0 1 1 | 0 1
    1 0 0 | 1 0 
    1 0 1 | 0 1
    1 1 0 | 0 1 
    1 1 1 | 1 1 

  s ::= a XOR b
  d ::= c(in) XOR s
  c(out) ::= (c(in) AND s) OR (a AND b)

# 2015 1.4.4 Truth Tables Equivalence Validity

A truth assignment assigns a value T or F to each propositional variable

Computer scientists call assignment of values to variables an environment.

If we know the environment we can find the value of a propositional formula

Two propositional formulas are equivalent if and only if (iff) they have
same truth values in all environments

## DeMorgan's Law

  !(P OR Q) equiv to !P AND !Q

Proof by truth table

  P Q | !(P OR Q) | !P AND !Q
  0 0 | 1         | 1
  0 1 | 0         | 0
  1 0 | 0         | 0
  1 1 | 0         | 0

## Definition of IFF

The value of (P IFF Q) is T iff P and Q have the same truth value

  P Q | P IFF Q
  T T | T
  T F | F
  F T | F
  F F | T

## Satisfiability and Validity

A formula is satisfiable iff it is true in some environment

A formula is valid iff it is true in *all* environments

  Satisfiable: P, NOT(P)

  Not satisfiable: P AND NOT(P) 

  Valid: P OR NOT(P)

## Equivalence and Validity

  G and H are equivalent
  G iff H is valid

## Verifying Valid, Satisfiable

Truth table size doubles with each additional variable

Exponential growth - doubling each time we add a variable.

For hundreds of variables the truth table size is unfeasible large (wouldn't
fit in the Universe???)

## Fast Test for SAT

One of the central problems in theoretical computer science is whether there
is a test for SAT that is more efficient than exhaustively searching

This is the abstract version of the P = NP problem.  P = NP is considered to
be the most important open problem in the theory of computer science and the
theory of computation.

Is there an "efficient" (polynomial rather than exponential time e.g.
quadratic or cubic) procedure to check satisfiability (SAT)

## SAT versus VALID

To check that G is valid can check that NOT(G) is not satisfiable i.e. there
is a least one environment where G is false.  "SAT and
VALID stand and fall together"

XXXSE I can't conceive of how SAT could be anything other than exponential in
the worst case.  Is P = NP about worst case?

# 2015 1.5.1 Predicate Logic 1

## Quantifiers

A predicate is a proposition with variables

  ∀ For ALL x

  ∃ There EXISTS some y

For ALL is like AND

  P(a) AND P(b) AND P(c) AND P(d) AND...

There EXISTS is like OR

  B(a) OR B(b) OR B(c) OR B(d) OR...

## Existential Quantifier

  Q(y) ::= there EXISTS some x where x < y 
  Q(3) is T([x<3] is T for x=1)
  Q(1) is T([x<1] is T for x=0)
  Q(0) is F([x<0] is not T for any x in Ν)

## Universal Quantifier

  x, y range over Ν
  R(1) is F([x<1] is F for x=5)

  "For ALL there EXISTS" is expensive

  We would prefer "there EXISTS for ALL"

## Alternating Quantifiers

  G ::= For ALL x there EXISTS y. x < y

x, y range over Domain of Discourse

  Domain      G is
  Ν           T
  ints < 0    F  (there is no negative integer < -1)
  reals < 0   T  (-r/2 is bigger than -r)

### Reverse the Quantifiers

  H ::= There EXISTS y for ALL x. x < y

  Domain            H is
    Ν                 F
    Ζ-                T (-1)
    R-                F

# 2015 1.5.2 Predicate Logic 2

## Validity and Satisfiability

Propositional Validity

True for all truth-values

Example:

  (P => Q) OR (Q => P)

  Environment
  P | Q | P => Q | Q => P |  
  F | F | T      | T      | T
  F | T | T      | F      | T
  T | F | F      | T      | T
  T | T | T      | T      | T

XXXSE I'm still confused by implications

Definition: An implication p implies q is true if p is false or q is true

  If pigs can fly => I am king

In maths we take an "innocent until proven guilty" approach i.e. true until
proven false.  This means that false implies true, because we have decided
that false cannot imply false.

Predicate Calculus Validity

## Universal Generalization (UG)

  P(c)
  --------------

  For ALL x. P(x)

True for all domains and predicates

XXXSE Not really sure what this is

### DeMorgan's Law for Quantifiers

  !(A OR B) = !A AND !B

XXXSE Oh.... so DeMorgan's law means you can short circuit which would be
faster in practice if it is probable that A is true

In fact if each variable has a 50% probability of being true then we can
calculate the probability of the test being short-circuited 1 - (1/2^n)

  For ALL x, NOT(P(x)) IFF NOT(there EXISTS x, P(xP)) 

XXXSE Yay I think I spotted an error on the slides

# 2015 1.5.4 Predicate Logic III - For ALL and there EXISTS in English

## Two Meta-Theorems

Meta-mathematics - the mathematics of mathematical logic

Poet:

"All that glitters is not gold"
              G            Au

  For ALL x [G(x) IMPLIES NOT(Au(x))]

No: gold glitters like gold!

"All that glitters it not necessarily gold"

  NOT(For ALL.[G(x) IMPLIES Au(x)])

Poet: "There is a season to every purposes under heaven"

  There EXIST S ε Season For ALL P ε Purposes.  s is for p

Some season, say Summer is good for all Purposes?  NO, Summer is no good for
snow shoveling

Poet's meaning flips the quantifiers

  For ALL p ε Purpose There EXISTS s ε Season.  s is for P

for snow shoveling, Winter is good
for planting, Sprint is good
for leaf watching, Fall is good

Translation from English to Math cannot be done in a mindless mechanical way.

## Two Profound Meta-Theorems about Mathematical Logic: Power & Limits of Logic

Godel's Completeness Theorem

Thm1, good news: only need to know a few axioms & rules to prove all valid
formulas(in theory; in practice need lots of rules)

Axioms & Inference Rules:  Rules are just UG and modus ponens.

Thm2, bad news: there is no procedure to determine whether a quantified
formula is valid (in contrast to propositional formulas).

Predicate calculus is undecidable - it's logically impossible to write a
computer program that will take an arbitrary predicate calculus formula in and
print out true or false depending on whether or not it is valid.

# 2015 1.6.1 Sets

The most fundamental of all mathematical data types

Informally: A set is a collection of mathematical objects, with the collection
treated as a single mathematical object.  (This is a circular definition of
course: what's a collection?)

Familiar sets

  Real numbers  
  Complex numbers
  Integers
  Empty set

* There is no notion of order in a set
* An element is in or not in a set
* No notion of being in the set more than once

Membership

x is a member of A: x ϵ A

Synonyms for Membership

  X ϵ A
  x is an element of A
  x is in A

## Subset

  A B   A is a subset of B

Every element of A is also an element of B

  For ALL x [x is in A IMPLIES x is in B]

Examples

  Ζ subset of Reals 
  Reals are subset of Complex numbers
  {3} is a subset of {5,7,3}

  A is a subset of A
  The empty set is a subset of everything

  For ALL x [xε0 IMPLIES xεB]

  Since xε0 is false the whole implication is true.  This is an example of why
that convention that false implies anything is true convenient.

## Defining Sets

The set of elements x in A such that P(x) is true

  { x ϵ A | P(x)}

"Vertical bar is read as such that"

## Power Set

  pow(A) ::= all the subsets of A

example:

  pow({T,F})={{T},{F},{T,F},{}}

  E ϵ pow(Ζ)
  Z ϵ pow(R)

  B ϵ pow(A) IFF B subset of A

# 2015 1.6.2 Sets: Operations

## New sets from old

### Union

  A ∪ B ::= {x|x ϵ A OR x ϵ B}

"You can begin to see a relationship between the union operation and the
propositional OR connective"

### Intersection

  A ∩ B ::= {x|x ϵ A AND x ϵ B}

## A set-theoretic equality

  A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)

proof: Show these have the same elements, namely

  x ϵ l.h.s iff x ϵ r.h.s, for all x

A general method is to take a set-theoretic equality and convert it to a
proposition equivalence

  A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)

  x ϵ A OR (x ϵ B AND x ϵ C) = (x ϵ A OR x ϵ B) AND (x ϵ A OR x ϵ C) 

  Invoke the propositional equivalence

  P OR (Q AND R) iff (P OR Q) AND (P OR R)

  XXXSE: Union distributes over intersection in the same way that
multiplication distributes over addition:

    a (b + c) = ab + ac

  XXXSE: Okay so that is equivalent to the propositional?

This is the way that automatic-engines like Mathematica can prove these
set-theoretic identities

### Difference

  A-B ::={x|x ϵ A AND x NOT ϵ B}

### Complement

  complement(A) ::= D-A = {x|NOT ϵ A}

  D = Domain of discourse

# 1.7.1 Relations & Functions

## Binary relations

A binary relation is a mathematical object that associates elements of a set
called the domain, with elements of another set called the codomain

"Relations are one of the most basic mathematical abstractions - right after
sets.  They play a role everywhere"

## Example

"Registered for" relation R

  "Jason is registered for 6.0.42"

Notation:

  Jason R 6.0.42              infix
  R(Jason, 6.0.42)            prefix
  (Jason, 6.042) ϵ R          the ordered pair (Jason, 6.042) is a member of the relation
  (Jason, 6.042) ϵ graph(R)   the ordered pair " is a member of the graph of the
relation
  
## Images under R

R(X) ::= all the subjects being taken by students in the set X

R(X) ::= endpoints of arrows from points in X

  R(X) ::= {jϵJ | There EXISTS dϵX. dRj}

  R(X) is the set of j in subjects such that there exists a d in X such that
an arrow goes from X to j

## Inverse (basically turning the arrows backwards)

Flip the role of the domain and the codomain

  dRj IFF jR⁻¹d 

aka the inverse image of Y under R

## Inverse image under R

All the stuDents registered for some subJect

  D is a subset of R⁻¹(J)

## Composing R and V

  Composition of R and V

  R∙V ::= R(V(X))

  p(R∙V)j IFF there EXISTS dϵD.[pVd AND dRj]

  pVd - There's a V arrow from p to d

  dRj - There's an R arrow from d to j

  The definition of R composed with V is that there is a d that connects p and
j through V and d

## Set operations on relations

  "You can think of the relations as the set of arrows" 

e.g. Profs should not teach their advisees:

In logical notation:

  ∀p∀j.NOT(p(R∙V(j AND pTj)

  T ∩ (R∙V) = empty set

  "The relationship of T intersected with the relationship of (R∙V) is empty -
there is no pair that is in both T and (R∙V)

Another way to say that R∙V and T have no points in common is to say that one
set is contained in the complement of the other set

  R∙V subset of complement(T)

## Binary relations

A binary relation, R, from a set A to a set B associates elements of A with
elements of B

A relation has three parts = the domain, the codomain and the set of arrows
going from the domain to the codomain

  graph(R) = set of ordered pairs from domain to codomain
          = {(a1,b2),(a1,b4),(a3,b4),...}

### range(R)

range(R) ::= elements with arrows coming in
  = R(A)

Typically the range is not equal to the whole codomain

### Functions are relations

A function, F, from A to B is a relation which associates each element, a, of
A with at most one element of B
                   called F(a)

"A relation is a function if there is *at most one arrow* coming out (there may
no arrow coming out)"

relation F:A->B is a function

IFF [aFb and aFb'] IMPLIES b=b'

# 1.7.3 Relation Mapping Properties (Archery)

## Total relation

* At least one arrow out of each domain element

## Total & Function

* Exactly 1 arrow out

"In lots of fields it is assumed functions are total."

  g(x,y) ::= 1/x-y

domain(g) = all pairs of reals
codomain(g) = all reals

But g is not total - g(r,r) is not defined

## Surjection

At least one arrow into every point in B

R is a surjection if the range is the codomain

  R(A) = B
  
## Injection

At most one arrow into every element in the codomain

## Bijection

Exactly 1 arrow out and exactly 1 arrow in

A bijection from A to B implies |A| = |B| for finite sets

# 1.7.5 Finite Cardinality

pow(A)

    |pow(A)| = 2^|a|

Size of the power set of a finite set A is to 2 to the power of the size of A

## Surjection function

  implies |A| >= |B| for finite A and B

## Total injective relation

  implies |A| <= |B| for finite A and B

## Infinite sets

Shroder-Bernstein theorom

# 1.8.1 Induction

## Proof by Induction

* Induction axiom
  - Let P(n) be a predicate.
  - If P(0) is true and
    for all natural numbers P(n) => P(n+1) is true
    then for all naturual numbers P(n) is true

* if P(0), P(0) => P(1), P(1) => P(2), P(2) => P(3), ...  are true
  - Like truth dominoes!

Theorem: For all natural numbers 1+2+3+...+n = n(n+1)/2

### Proof: by induction

### Let P(n) be proposition that that for all natural numbers 1+2+3+...+n = n(n+1)/2

First check the base case P(0)

### Base Case P(0) is true

  0 = 0(0+1)/2

### Inductive Step 

  - For n >= 0, show P(n) => P(n+1) is true

Assume P(n) is true for purposes of induction

i.e. we assume 1+2+...+n = n(n+1)/2

  - We are assuming this within the context of establishing that the
    implication is true

Need to show 1+2+...+n+(n+1) = (n+1)(n+2)/2

        n(n+1)/2 + (n+1) = 
        n(n+1)/2 + (2n+2) =
        n²+n+2n+2/2

Often induction gives you no hints - it just proves it is right once you have
the answer!
  - XXXSE What the fudge?

## Thm: For all n   3 | (n³-n)

Ex: n=5   3 | 125-5

Pf: by induction

let P(n) 3 | (n³-n)

Base case:  3 | (0³-0)

Inductive Step:

For n >= 0, show P(n) => P(n+1) is True

Assume P(n) is true for purposes of induction

Examine 3 | ((n+1)³-(n+1))

                       n³+3n²+3n+1 - (n+1)
                       n³+3n²+2n

Use the fact P(n) is true to rewrite

                    (n³-n) + 3n² + 3n

by the inductive hypothesis P(n)

## Thm For all n there exists a way to tile a 2^n X 2^n region with a centre
square untiled

### Pf: by induction

P(n) 

### Base case

P(0) = One square (2^0) - centre square is untiled

### Ind step: For n=0, assume P(n) to verify I.H.

So we need to show P(n+1) is true

Consider a 2^(n+1) X 2^(n+1) courtyard

One general technique to use if the inductive hypothesis doesn't work you can
is to take a *stronger* one (e.g. a more general one).

We change the proposition to say we can tile a 2^n region with *any* square
untiled.

A stronger induction hypothesis is often easier to proove.

# 1.8.2 Bogus Induction

Understanding proofs includes the ability to spot mistakes in them.

## Thm (not!) All horses are the same colour

Pf: by induction

P(n) In any set of n horses (n>=1) the horses are all the same colour

### Base case: P(1)

P(1)  - All horses are the same colour

### Inductive Step: Assume P(n) to proove P(n+1)

Consider any set of n+1 horses H1, H2,..., Hn+1

Then H1, H2, ..., Hn are all the same colour (because P(n) is assumed true)

  H2, H3, ..., Hn+1 are all the same colour (because P(n) is assumed true)

Since colour(H1) = colour(H2,..,Hn) = colour(Hn+1)
all n+1 are the same colour

The error is in the ellipsis (...)

In the case of P(2) colour(H1) = colour({}) breaking the equality with P(n+1)

You have to establish the inductive step for all n bigger than the base case

# 1.8.4 Strong Induction

A little easier to use when solving certain problems

Strong Induction Axiom

Let P(n) be any predicate.  If P(0) is true and for all n, P(0) and P(1) and
P(n) are all true implies P(n+1) is true, then P(n) is true for all n

  ∀n.P(n)

The only difference between strong induction and ordinary induction is what we
get to assume all from P(0) to P(n) is true

## Postage by Strong Induction

Can make any amount >= 8c with a combination of 3 and 5

  P(n) ::= can form n + 8

  P(0) ::= 5x1 + 3x1
  P(1) ::= 5x0 + 3x3
  
With strong induction we can assume P(0),P(1),P(2),..,P(n) is true

  P(n) => P(n+1)

  P(n) => P(n+3) - because it's just P(n) + 1x3
  P(n-2) => P(n+1)?

We conclude by strong induction that using 3c and 5c stamps, n+8c postage can
be formed for all n >= 0

## Unstacking game

Start: A stack of boxes
Move: Split any stack into of sizes a,b>0
Scoring: a x b points
Keep moving: until stuck
Overall score: sum of move scores

P(n) = Σ(n) from 1..(n-1)
     = (n-1)(n-2)/2
P(0) = 0
P(1) = 0
P(2) = 2 (1+1)
P(3) = 5 (3+2)
P(n) => P(n+1)

Claim: Every way of unstacking n blocks gives the same score

Ex: S(8) = 28

Pf: By strong induction with Claim(n) as hypothesis

Induction hypotheses P(n) 

Base case   n=1 S(1) = 0
Ind. step: Assume for stacks <= n, and prove C(n+1): 

Look at n+1 blocks

XXXSE: Can you also look at this like an optimisation problem? The maximum
score of a+b is the maximum score of a + maximum score of b

What is that thing called?  Optimial substrcture?  The optimial solution to
subproblems form part of the optimial solution the whole problem

Does this problem have optimial substructure?  How does that relate to DP?

XXXSE: DP requires optimial substructure and independence
  - Optimial substructure - the optimial solution to a subproblem is part of
    the optimial solution of the global solution
  - Independence - this is about the solution to one sub-problem being an
    input into the solution to another sub-problem.  Independt sub-problems could be
calculated independently in any order or in parallel.
  - DP Has overlapping sub-problems which are indepedent.  The terminology
    could be confusing but this means that we can memoise solutions to
sub-problems to calculate the solution to a other sub-problems - classic
example is fibonacci
- Shortest path is a classic example of optimial substructure.

  Aldestrop -> Conventry

  Aldestrop -> (Bristol) -> Coventry

Intuitively the solution B->C does not dependent on the solution A->B (it is
not an input into it - we do not need to wait for the answer to A->B before we can
start working on B->C)
(although their solutions may overlap)

If the SP of A->C goes through B, then A->C must include the SP from A->B and
B->C.  If it didn't there would be a shorter SP.

So - is this a DP problem?

Does it have optimal sub-structure?
1. Are the sub-problems independent?
2. Are the sub-problems overlapping?

DP versus divide and conquer

Classic d&c is merge sort.  No overlap.  Bugger - aren't the sub-problems
dependent?

What does this problem look like in reverse?  Can all DP problems been done in
reverse?

So does this problem have optimal substructure?  I guess we need to induction
prove this? Argh

The optimal solution to S(a+b) is optimal S(a) + optimal S(b)

1. Independent - yes you can calculate S(a) S(b) independently (in any order,
   in parallel, one does not depend on the input of another)
2. Monotonic - yes more blocks = higher score

So it looks like it has optimal sub-structure


Is this DP?

Yes it looks like the problems are overlapping - the solution to S(7)



How many ways are there to complete the problem?

  0 -> 1
  1 -> 2
  2 -> 3 (1,1),(2,0),(0,2)
  3 ->   (3,0),(0,3),(2,1),(1,2) 


Generally speaking a proof is going to have seven characteristics

Good proofs are:

1. Correct
2. Complete
3. Clear
4. Brief
5. "Elegant" (The mathematicians notion of beauty)
6. Well Organised
7. In Order 

It's estimated that 1/3 of all published proofs have flaws that render the
proof incorrect.
  - XXXSE Woah

## Proof techniques you should not use

1. Proof by throwing in the kitchen sink
2. Proof by example
3. Proof by vigorous hand waving
4. Proof by cumbersome notation
5. Proof by exhaustion
6. Proof by omission
7. Proof by picture
8. Proof by vehement assertion
9. Proof by appeal to intuition
10. Proof by reference to relevant authority

## Letter sliding 

  A B C       A B C
  D E F   ->  D E F
  H G         G H

Legal move: Slide a letter

Thm: There is no sequence of legal moves to invert G and H and return all the
other letters to their original position

What is the invariant?

### Row move
                              Naturual order
Ex    A B C       A B C       1 2 3
      D G     ->  D   G       4   5
      E F H       E F H       6 7 8

Lemma 1: A row move does not change the order of the items

Proof: In a row move, we move item from cell i into cell i-1 or i+1.  Nothing
else moves.  Hence the order of the items is preserved

### Column move

Ex    A B C      A B C
      D F     -> D F G
      H E G      H E 

In a column move, we move item from cell i into cell i-3 or i+3.

"When we say don't do proof by example we don't mean don't try examples"

Lemma 2: A column move changes the relative order of precisely 2 pairs of
items

Proof: In a column move, we move an item in cell i to a blank spot in a cell
i+3 or i-3.  When an item moves 3 positions it changes relative order with 2
other items (i-1, i-2 or i+1, i+2)

Def: A pair of letters L1 and L2 form an inverted pair if L1 precedes L2
in the alphabet but L1 appears after L2 in the puzzle

If we start with an odd number of inverted pairs, we will always end with an
odd number of inverted pairs.

Lemma 3: During a move, the # of inversions can only increase by 2, decrease
by 2, or stay the same.

Pf: Row move: No changes (lemma 1)
    Column move: 2 pairs change (by lemma 2)

Corollary 1: During a move parity (even/odd) of the #inversions does not
change.

  - A Corollary usually is something that is a simple consequence of something
    else - it usually has a short proof
  - Lemma is something that you are going to use as a tool for a bigger thing,
    often a theorom or another lemma

Pf: Adding or subtracting 2 does not change the parity

Lemma 4: In every state reachable from the start state, the parity of #
inversions is odd.

Pf: by induction

P(n) After any sequence of n moves from the start state the parity of
number of inversions is odd

Base case P(0)


Base Case: 2 letters?

Pf of Thm: The parity of # inversions in desired state is even (0).  By
Lemma 4, the desired state cannot be reached from the start state

Invariant: You are looking for a property that holds at the beginning, is
preserved by every step, but is not present in the target state.

Software: You would like to proove that any "sequence of moves" you never reach
the meltdown state.

# Lecture 4: Number Theory I

Study of the integers (0, 1, 2, 3, ...)

Number theory got used in cryptography about 40 years ago (1970's)

Def m | a (m divides a)

  if and only if there exists an integer k such that a = k.m

  3 | 6

  Every number divides zero

Suppose a-gallon jug, b-gallon jug

  a = 3, b = 5
  a <= b 

Thm: m|a and m|b, then m| any result

## State machine

States: pairs (x, y), where x = # gal in a-jug, y = # gal in b=jug

Start-state: (0, 0)

### Transitions

  A, B
  # emptying
  (x, y)  -> (0, y) # empty a
  (x, y)  -> (x, 0) # empty b
  # filling
  (x, y)  -> (A, y) # fill a
  (x, y)  -> (x, B) # fill b
  # pouring
  (x, y)  -> (0, x+y) if x+y <= B
  (x, y)  -> (x+y, 0) if x+y <= A
  (x, y)  -> (A, y-(A-x)) = (A, y+x-A) if x+y > A
  (x, y)  -> (x-(B-y), B) = (x+y-B, B) if x+y > B

Pf (by induction)

Assume m|a, m|b

Invariant: P(n) = "If (x, y) is the state after n transitions, then m|x, m|y"

  P(0) = (0, 0), m|0 => true

Inductive step: Assume P(n)

  P(n) => P (n+1)

  a = 33, b = 55

  Can we make 4 gallons?  No because a and b are divisible by 11, every result
also has to be divisible by 11 

Definitions

  gcd - greatest common divisor
  relatively prime - when gcd(a, b) = 1

Thm: m|a and m|b, then gcd(a, b)| any result

Thm: Any linear combination L = s.a + t.b, of a and b
      with 0 <= L <= b can be reached

I Nearly understood this

## Euclid's algorithm

There exists a unique quotient (q) and remainder (r) such that b=qa+r with the
property that 0 <= r <= a

### Lemma

  gcd(a, b) = gcd(rem(b, a), a)

e.g.
  gcd(3, 5) = gcd(rem(5, 3), 3) = gcd(2, 3) = 1

  gcd(9, 12) = gcd(rem(12, 9), 9) = gcd(3, 9)
  gcd(3, 9) = gcd(rem(9, 3), 3) = gcd(0, 3) = 2

  gcd(105, 224) = gcd(rem(224, 105), 105) = gcd(14, 105)
  gcd(14, 105) = gcd(rem(105, 14), 14) = gcd(7, 14)
  gcd(7, 14) = gcd(rem(14, 7), 7) = gcd(0, 7) = 7 

### Thm: gcd(a, b) is a linear combination of a and b

Pf (by induction)

P(n) "If Euclid's algorithm reaches gcd(x, y) after n steps, then x and y are
linear combinations of a and b, gcd(a, b) = gcd(x, y)

Base case: P(0) x = a, b = y
Inductive Step: Assume P(n)

Nope.

# 2015 2.1.1 GCDs & linear combinations

Number theory has quite elegant proofs and illustrates contradiction,
induction and WOP.

Arithmetic assumptions (some examples)

Distributivity of multiplication over plus

  a (b + c) = ab + ac

Commutativity of multiplication

  ab = ba

Associativity of multiplication

  (ab)c = a(bc)

Additive inverse 

  a - a = 0

Additive identity

  a + 0 = a

## The division theorem

For b > 0 and a have

  q = quotient(a, b)
  r = remainder(a, b)

  a = qb + r and 0 <= r <= b

## Divisibility

  c divides a (c|a) if and only if
  a = k.c for some k

  5|15 because 15 = 3.5
  n|0 because 0 = 0.n

## Simple divisibility facts

If c divides a, then c divides any constant times a

  c|a implies c|(sa)

To proves that c | (sa) we just need to show that (sa) = (some integer constant) X c

  c|a => a = k.c

  # We can multiply both sides by s to show that c|(sa)

  (sa) = (sk)c

if c|a and c|b then c|(a+b)

  e.g. if 3|6 and 3|9 then 3|15

  a = k.c, b = l.c
  (a+b) = (k.c) + (l.c)
  (a+b) = (k+l)c # by distributivity of multiplication over plus

if c|a and c|b then c²|(ab)

  a = k.c, b = l.c
  ab = kclc
  ab = (kl)c² = (klc)c

if c|a and c|b and c|d then c³|(abc)

if c|a and c|b then

  c | sa + tb

  this is an integer linear combination of a and b

  (sa + tb) = kc
  a = l.c, b=m.c # by the division rule, some constant multiplied by c = a
  (sa) = (sl)c # multiply both sides by a constant 
  (tb) = (tm)c 
  sa + tb = (sl)c + (tm)c
  sa + tb = (sl + tm)c # distributivity of * over +
  sa + tb =    (k)   c # call (sl + tm) k - by the division rule c is a divisor
of (sa + tb)

"Common divisors of a and b divide integer linear combinations of a and b"

e.g.

  3|12, 15 

  3|(s.12 + t.15)

gcd(a, b) ::= the greatest common divisor of a and b

The GCD exists by the WOP as it is a set of non-negative integers with an
upper bound.  The set is guaranteed to be non-empty because 1 is always a
divisor.
  XXXSE What does the WOP say about upper bounds?

  gcd(10, 12) = 2
  gcd(13, 12) = 1

  gcd(17, 17) = 17
  gcd(0, n) = n for n > 0

lemma: p prime implies gcd(p, a) = 1 or p (if p is a divisor of a)

# 2015 2.1.2 Euclidian Algorithm

## Computing GCDs

The gcd of two numbers is easy to compute

GCD Remainder Lemma:

gcd(a,b) = gcd(b, rem(a, b))

Proof: a = qb + r

so a, b and b, r have the same divisors

Example: a = 899, b = 493

GCD(899, 493) = 
GCD(493, 406) = 
GCD(406, 87) = 
GCD(87, 58) = 
GCD(58, 29) = 
GCD(29, 0) = 29

### Euclidian Algorithm as a State machine

States ::= N X N # non negative integers
Start ::= (a, b)
State transitions defined by 
  (x, y) -> (y, rem(x, y))
for y != 0

by Lemma, gcd(x, y) is constant so preserved invariant is

at termination (if any) x = gcd(a, b)

Proof: at termination y = 0 so

  gcd(a, b) = gcd(x, 0) = x 

GCD termination

y halves or smaller at every other step so it termination must be after no
more than 2 X log2(y) steps

# 2015 2.1.2 GCD's & linear combinations: The Pulverizer

GCD = Greatest Common Divisor

Extended Euclidian Algorithm (name The Pulverizer dating back to ancient
India)

Theorem:

gcd(a, b) is an integer linear combination of a and b

gcd(a, b) = sa + tb

Corollary: The multiples of gcd(a, b) are exactly the linear combinations of a
and b

Proof: Show how to find coefficients s, t

Method: Apply Euclidian Algorithm, finding coefficients as you go

# 2015 2.1.6 Number Theory: Die Hard Unique Factorization


